// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using global::System.Runtime.Versioning;
using winmdroot = global::Windows.Win32;
[assembly: global::System.Reflection.AssemblyMetadata("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
namespace Windows.Win32
{

  /// <content>
  /// Contains extern methods from "KERNEL32.dll".
  /// </content>
  [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
  internal static partial class PInvoke
  {
    /// <summary>Closes an open object handle.</summary>
    /// <param name="hObject">A valid handle to an open object.</param>
    /// <returns>
    /// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
    /// </returns>
    /// <remarks>
    /// <para>The <b>CloseHandle</b> function closes handles to the following objects: </para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/handleapi/nf-handleapi-closehandle#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.BOOL CloseHandle(winmdroot.Foundation.HANDLE hObject);

    /// <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
    /// <param name="hLibModule">
    /// <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
    /// </returns>
    /// <remarks>
    /// <para>The system maintains a per-process reference count for each loaded module. A  module that was loaded at process initialization due to load-time dynamic linking has a reference count of one. The reference count for a module is incremented each time the  module is loaded by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>. The reference count is also incremented by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> unless the  module  is being loaded for the first time and is being loaded as   a data or image file. The reference count is decremented each time the <b>FreeLibrary</b> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function is called for the module. When a  module's reference count reaches zero or the process terminates, the system unloads the module from the address space of the  process. Before unloading a library module, the system enables the module to detach from the process by calling the module's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function, if it has one, with the DLL_PROCESS_DETACH value. Doing so gives the library module an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process. It is not safe to call <b>FreeLibrary</b> from <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. Calling <b>FreeLibrary</b> does not affect other processes that are using the same module. Use caution when calling <b>FreeLibrary</b> with a handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. The <b>GetModuleHandle</b> function does not increment a module's reference count, so passing this handle to <b>FreeLibrary</b> can cause a module to be unloaded prematurely. A thread that must unload the DLL in which it is executing and then terminate itself should call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> instead of calling <b>FreeLibrary</b> and <b>ExitThread</b> separately. Otherwise, a race condition can occur. For details, see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.1.2600")]
    internal static extern winmdroot.Foundation.BOOL FreeLibrary(winmdroot.Foundation.HMODULE hLibModule);

    /// <inheritdoc cref="GetModuleHandle(winmdroot.Foundation.PCWSTR)"/>
    [SupportedOSPlatform("windows5.1.2600")]
    internal static unsafe FreeLibrarySafeHandle GetModuleHandle(string lpModuleName)
    {
      fixed (char* lpModuleNameLocal = lpModuleName)
      {
        winmdroot.Foundation.HMODULE __result = PInvoke.GetModuleHandle(lpModuleNameLocal);
        return new FreeLibrarySafeHandle(__result, ownsHandle: false);
      }
    }

    /// <summary>Retrieves a module handle for the specified module. The module must have been loaded by the calling process. (Unicode)</summary>
    /// <param name="lpModuleName">
    /// <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
    /// <para>If this parameter is NULL, <b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file). The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>If the function succeeds, the return value is a handle to the specified module. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process. If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com/windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> to specify a memory location rather than a DLL name. The <b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the <b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely. This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("KERNEL32.dll", ExactSpelling = true, EntryPoint = "GetModuleHandleW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.1.2600")]
    internal static extern winmdroot.Foundation.HMODULE GetModuleHandle(winmdroot.Foundation.PCWSTR lpModuleName);

    /// <inheritdoc cref="LoadLibrary(winmdroot.Foundation.PCWSTR)"/>
    [SupportedOSPlatform("windows5.1.2600")]
    internal static unsafe FreeLibrarySafeHandle LoadLibrary(string lpLibFileName)
    {
      fixed (char* lpLibFileNameLocal = lpLibFileName)
      {
        winmdroot.Foundation.HMODULE __result = PInvoke.LoadLibrary(lpLibFileNameLocal);
        return new FreeLibrarySafeHandle(__result, ownsHandle: true);
      }
    }

    /// <summary>Loads the specified module into the address space of the calling process. (LoadLibraryW)</summary>
    /// <param name="lpLibFileName">
    /// <para>The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file). If the specified module is an executable module, static imports are not loaded; instead, the module is loaded as if by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexw">LoadLibraryEx</a> with the `DONT_RESOLVE_DLL_REFERENCES` flag. The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. If the string specifies a full path, the function searches only that path for the module. If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module; for more information, see the Remarks. If the function cannot find the  module, the function fails. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>. If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension ".DLL" to the module name. To prevent the function from appending ".DLL" to the module name, include a trailing point character (.) in the module name string.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>If the function succeeds, the return value is a handle to the module. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>To enable or disable error messages displayed by the loader during DLL loads, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> function. <b>LoadLibrary</b> can be used to load a library module into the address space of the process and return a handle that can be used in <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> to get the address of a DLL function. <b>LoadLibrary</b> can also be used to load other executable modules. For example, the function can specify an .exe file to get a handle that can be used in <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a>. However, do not use <b>LoadLibrary</b> to run an .exe file. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> function. If the specified module is a DLL that is not already loaded for the calling process, the system calls the DLL's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function with the <b>DLL_PROCESS_ATTACH</b> value. If <b>DllMain</b> returns <b>TRUE</b>, <b>LoadLibrary</b> returns a handle to the module. If <b>DllMain</b> returns <b>FALSE</b>, the system unloads the DLL from the process address space and <b>LoadLibrary</b> returns <b>NULL</b>. It is not safe to call <b>LoadLibrary</b> from <b>DllMain</b>. For more information, see the Remarks section in <b>DllMain</b>. Module handles are not global or inheritable. A call to <b>LoadLibrary</b> by one process does not produce a handle that another process can use — for example, in calling <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>. The other process must make its own call to <b>LoadLibrary</b> for the module before calling <b>GetProcAddress</b>. If <i>lpFileName</i> does not include a path and there is more than one loaded module with the same base name and extension, the function returns a handle to the module that was loaded first. If no file name extension is specified in the <i>lpFileName</i> parameter, the default library extension .dll is appended. However, the file name string can include a trailing point character (.) to indicate that the module name has no extension. When no path is specified, the function searches for loaded modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds. Otherwise, the function searches for the file. The first directory searched is the directory containing the image file used to create the calling process (for more information, see the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> function). Doing this allows private dynamic-link library (DLL) files associated with a process to be found without adding the process's installed directory to the PATH environment variable. If a relative path is specified, the entire relative path is appended to every token in the DLL search path list. To load a module from a relative path without searching any other path, use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName</a> to get a nonrelative path and call <b>LoadLibrary</b> with the nonrelative path. For more information on the DLL search order, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>. The search path can be altered using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setdlldirectorya">SetDllDirectory</a> function. This solution is recommended instead of using <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcurrentdirectory">SetCurrentDirectory</a> or hard-coding the full path to the DLL. If a path is specified and there is a redirection file for the application, the function searches for the module in the application's directory. If the module exists in the application's directory, <b>LoadLibrary</b> ignores the specified path and loads the module from the application's directory. If the module does not exist in the application's directory, <b>LoadLibrary</b> loads the module from the specified directory. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>. If you call <b>LoadLibrary</b> with the name of an assembly without a path specification and the assembly is listed in the system compatible manifest, the call is automatically redirected to the side-by-side assembly. The system maintains a per-process reference count on all loaded modules. Calling <b>LoadLibrary</b> increments the reference count. Calling the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function decrements the reference count. The system unloads a module when its reference count reaches zero or when the process terminates (regardless of the reference count). <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables: <b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the DLL explicitly using <b>LoadLibrary</b> on versions of Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local storage functions instead of <b>_declspec(thread)</b>. For an example, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>. <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3> Do not use the <a href="https://docs.microsoft.com/windows/desktop/api/processenv/nf-processenv-searchpathw">SearchPath</a> function to retrieve a path to a DLL for a subsequent <b>LoadLibrary</b> call. The <b>SearchPath</b> function uses a different search order than <b>LoadLibrary</b> and it does not use safe process search mode unless this is explicitly enabled by calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setsearchpathmode">SetSearchPathMode</a> with <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore, <b>SearchPath</b> is likely to first search the user’s current working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current working directory, the path retrieved by <b>SearchPath</b> will point to the malicious DLL, which <b>LoadLibrary</b> will then load. Do not make assumptions about the operating system version based on a <b>LoadLibrary</b> call that searches for a DLL. If the application is running in an environment where the DLL is legitimately not present but a malicious version of the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended techniques described in <a href="https://docs.microsoft.com/windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("KERNEL32.dll", ExactSpelling = true, EntryPoint = "LoadLibraryW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.1.2600")]
    internal static extern winmdroot.Foundation.HMODULE LoadLibrary(winmdroot.Foundation.PCWSTR lpLibFileName);

    /// <inheritdoc cref="GetProcAddress(winmdroot.Foundation.HMODULE, winmdroot.Foundation.PCSTR)"/>
    [SupportedOSPlatform("windows5.1.2600")]
    internal static unsafe winmdroot.Foundation.FARPROC GetProcAddress(SafeHandle hModule, string lpProcName)
    {
      bool hModuleAddRef = false;
      try
      {
        fixed (byte* lpProcNameLocal = lpProcName is object ? global::System.Text.Encoding.Default.GetBytes(lpProcName) : null)
        {
          winmdroot.Foundation.HMODULE hModuleLocal;
          if (hModule is object)
          {
            hModule.DangerousAddRef(ref hModuleAddRef);
            hModuleLocal = (winmdroot.Foundation.HMODULE)hModule.DangerousGetHandle();
          }
          else
            throw new ArgumentNullException(nameof(hModule));
          winmdroot.Foundation.FARPROC __result = PInvoke.GetProcAddress(hModuleLocal, new winmdroot.Foundation.PCSTR(lpProcNameLocal));
          return __result;
        }
      }
      finally
      {
        if (hModuleAddRef)
          hModule.DangerousRelease();
      }
    }

    /// <summary>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</summary>
    /// <param name="hModule">
    /// <para>A handle to the DLL module that contains the function or variable. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-loadpackagedlibrary">LoadPackagedLibrary</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function returns this handle. The <b>GetProcAddress</b> function does not retrieve addresses from modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
    /// <returns>
    /// <para>If the function succeeds, the return value is the address of the exported function or variable. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>The spelling and case of a function name pointed to by <i>lpProcName</i> must be identical to that in the <b>EXPORTS</b> statement of the source DLL's module-definition (.def) file. The exported names of functions may differ from the names you use when calling these functions in your code. This difference is hidden by macros used in the SDK header files. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. The <i>lpProcName</i> parameter can identify the DLL function by specifying an ordinal value associated with the function in the <b>EXPORTS</b> statement. <b>GetProcAddress</b> verifies that the specified ordinal is in the range 1 through the highest ordinal value exported in the .def file. The function then uses the ordinal as an index to read the function's address from a function table. If the .def file does not number the functions consecutively from 1 to <i>N</i> (where <i>N</i> is the number of exported functions), an error can occur where <b>GetProcAddress</b> returns an invalid, non-NULL address, even though there is no function with the specified ordinal. If the function might not exist in the DLL module—for example, if the function  is available only on Windows Vista but the application  might be running on Windows XP—specify the function by name rather than by ordinal value and design your application to handle the case when the function is not available, as shown in the following code fragment.</para>
    /// <para></para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.1.2600")]
    internal static extern winmdroot.Foundation.FARPROC GetProcAddress(winmdroot.Foundation.HMODULE hModule, winmdroot.Foundation.PCSTR lpProcName);
  }


  /// <content>
  /// Contains extern methods from "USER32.dll".
  /// </content>
  internal static partial class PInvoke
  {
    /// <summary>Destroys an icon and frees any memory the icon occupied.</summary>
    /// <param name="hIcon">
    /// <para>Type: <b>HICON</b> A handle to the icon to be destroyed. The icon must not be in use.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>It is only necessary to call <b>DestroyIcon</b> for icons and cursors created with the following functions: <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> (if called without the <b>LR_SHARED</b> flag), <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyicon">CopyIcon</a>. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon. </para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.BOOL DestroyIcon(winmdroot.UI.WindowsAndMessaging.HICON hIcon);

    /// <summary>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</summary>
    /// <param name="hCursor">
    /// <para>Type: <b>HCURSOR</b> A handle to the cursor to be destroyed. The cursor must not be in use.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>The <b>DestroyCursor</b> function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor: </para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.BOOL DestroyCursor(winmdroot.UI.WindowsAndMessaging.HCURSOR hCursor);

    /// <summary>Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function. (RegisterClassW)</summary>
    /// <param name="lpWndClass">
    /// <para>Type: <b>const WNDCLASS*</b> A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure. You must fill the structure with the appropriate class attributes before passing it to the function.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>ATOM</b> If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>If you register the window class by using <b>RegisterClassA</b>, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using <b>RegisterClassW</b>, the application requests that the system pass text parameters of messages as Unicode. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-iswindowunicode">IsWindowUnicode</a> function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. All window classes that an application registers are unregistered when it terminates. No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "RegisterClassW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern ushort RegisterClass(in winmdroot.UI.WindowsAndMessaging.WNDCLASSW lpWndClass);

    /// <inheritdoc cref="LoadCursor(winmdroot.Foundation.HINSTANCE, winmdroot.Foundation.PCWSTR)"/>
    [SupportedOSPlatform("windows5.0")]
    internal static unsafe DestroyCursorSafeHandle LoadCursor(SafeHandle hInstance, string lpCursorName)
    {
      bool hInstanceAddRef = false;
      try
      {
        fixed (char* lpCursorNameLocal = lpCursorName)
        {
          winmdroot.Foundation.HINSTANCE hInstanceLocal;
          if (hInstance is object)
          {
            hInstance.DangerousAddRef(ref hInstanceAddRef);
            hInstanceLocal = (winmdroot.Foundation.HINSTANCE)hInstance.DangerousGetHandle();
          }
          else
            hInstanceLocal = (winmdroot.Foundation.HINSTANCE)new IntPtr(0L);
          winmdroot.UI.WindowsAndMessaging.HCURSOR __result = PInvoke.LoadCursor(hInstanceLocal, lpCursorNameLocal);
          return new DestroyCursorSafeHandle(__result, ownsHandle: false);
        }
      }
      finally
      {
        if (hInstanceAddRef)
          hInstance.DangerousRelease();
      }
    }

    /// <summary>Loads the specified cursor resource from the executable (.EXE) file associated with an application instance. (Unicode)</summary>
    /// <param name="hInstance">
    /// <para>Type: <b>HINSTANCE</b> A handle to an instance of the module whose executable file contains the cursor to be loaded.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursorw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="lpCursorName">
    /// <para>Type: <b>LPCTSTR</b> The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro can also be used to create this value. To use one of the predefined cursors, the application must set the <i>hInstance</i> parameter to <b>NULL</b> and the <i>lpCursorName</i> parameter to one the following values. </para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursorw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>HCURSOR</b> If the function succeeds, the return value is the handle to the newly loaded cursor. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>The <b>LoadCursor</b> function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to the existing resource. This function returns a valid cursor handle only if the <i>lpCursorName</i> parameter is a pointer to a cursor resource. If <i>lpCursorName</i> is a pointer to any type of resource other than a cursor (such as an icon), the return value is not <b>NULL</b>, even though it is not a valid cursor handle. The <b>LoadCursor</b> function searches the cursor resource most appropriate for the cursor for the current display device. The cursor resource can be a color or monochrome bitmap. <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3> This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursorw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "LoadCursorW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.UI.WindowsAndMessaging.HCURSOR LoadCursor(winmdroot.Foundation.HINSTANCE hInstance, winmdroot.Foundation.PCWSTR lpCursorName);

    /// <inheritdoc cref="LoadIcon(winmdroot.Foundation.HINSTANCE, winmdroot.Foundation.PCWSTR)"/>
    [SupportedOSPlatform("windows5.0")]
    internal static unsafe DestroyIconSafeHandle LoadIcon(SafeHandle hInstance, string lpIconName)
    {
      bool hInstanceAddRef = false;
      try
      {
        fixed (char* lpIconNameLocal = lpIconName)
        {
          winmdroot.Foundation.HINSTANCE hInstanceLocal;
          if (hInstance is object)
          {
            hInstance.DangerousAddRef(ref hInstanceAddRef);
            hInstanceLocal = (winmdroot.Foundation.HINSTANCE)hInstance.DangerousGetHandle();
          }
          else
            hInstanceLocal = (winmdroot.Foundation.HINSTANCE)new IntPtr(0L);
          winmdroot.UI.WindowsAndMessaging.HICON __result = PInvoke.LoadIcon(hInstanceLocal, lpIconNameLocal);
          return new DestroyIconSafeHandle(__result, ownsHandle: true);
        }
      }
      finally
      {
        if (hInstanceAddRef)
          hInstance.DangerousRelease();
      }
    }

    /// <summary>Loads the specified icon resource from the executable (.exe) file associated with an application instance. (Unicode)</summary>
    /// <param name="hInstance">
    /// <para>Type: <b>HINSTANCE</b> A handle to an instance of the module whose executable file contains the icon to be loaded. This parameter must be <b>NULL</b> when a standard icon is being loaded.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="lpIconName">
    /// <para>Type: <b>LPCTSTR</b> The name of the icon resource to be loaded. Alternatively, this parameter can contain the resource identifier in the low-order word and zero in the high-order word. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>HICON</b> If the function succeeds, the return value is a handle to the newly loaded icon. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para><b>LoadIcon</b> loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing resource. The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be a color or monochrome bitmap. <b>LoadIcon</b> can only load an icon whose size conforms to the <b>SM_CXICON</b> and <b>SM_CYICON</b> system metric values. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> function to load icons of other sizes.</para>
    /// <para>> [!NOTE] > The winuser.h header defines LoadIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "LoadIconW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.UI.WindowsAndMessaging.HICON LoadIcon(winmdroot.Foundation.HINSTANCE hInstance, winmdroot.Foundation.PCWSTR lpIconName);

    /// <inheritdoc cref="UnregisterClass(winmdroot.Foundation.PCWSTR, winmdroot.Foundation.HINSTANCE)"/>
    [SupportedOSPlatform("windows5.0")]
    internal static unsafe winmdroot.Foundation.BOOL UnregisterClass(string lpClassName, SafeHandle hInstance)
    {
      bool hInstanceAddRef = false;
      try
      {
        fixed (char* lpClassNameLocal = lpClassName)
        {
          winmdroot.Foundation.HINSTANCE hInstanceLocal;
          if (hInstance is object)
          {
            hInstance.DangerousAddRef(ref hInstanceAddRef);
            hInstanceLocal = (winmdroot.Foundation.HINSTANCE)hInstance.DangerousGetHandle();
          }
          else
            hInstanceLocal = (winmdroot.Foundation.HINSTANCE)new IntPtr(0L);
          winmdroot.Foundation.BOOL __result = PInvoke.UnregisterClass(lpClassNameLocal, hInstanceLocal);
          return __result;
        }
      }
      finally
      {
        if (hInstanceAddRef)
          hInstance.DangerousRelease();
      }
    }

    /// <summary>Unregisters a window class, freeing the memory required for the class. (Unicode)</summary>
    /// <param name="lpClassName">
    /// <para>Type: <b>LPCTSTR</b> A null-terminated string or a class atom. If <i>lpClassName</i> is a string, it specifies the window class name. This class name must have been registered by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. System classes, such as dialog box controls, cannot be unregistered. If this parameter is an atom, it must be a class atom created by a previous call to the <b>RegisterClass</b> or <b>RegisterClassEx</b> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unregisterclassw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="hInstance">
    /// <para>Type: <b>HINSTANCE</b> A handle to the instance of the module that created the class.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unregisterclassw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the class could not be found or if a window still exists that was created with the class, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>Before calling this function, an application must destroy all windows created with the specified class. All window classes that an application registers are unregistered when it terminates. Class atoms are special atoms returned only by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>. No window classes registered by a DLL are unregistered when the .dll is unloaded.</para>
    /// <para>> [!NOTE] > The winuser.h header defines UnregisterClass as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unregisterclassw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "UnregisterClassW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.BOOL UnregisterClass(winmdroot.Foundation.PCWSTR lpClassName, winmdroot.Foundation.HINSTANCE hInstance);

    /// <summary>The MonitorFromPoint function retrieves a handle to the display monitor that contains a specified point.</summary>
    /// <param name="pt">A <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that specifies the point of interest in virtual-screen coordinates.</param>
    /// <param name="dwFlags">Determines the function's return value if the point is not contained within any display monitor.</param>
    /// <returns>
    /// <para>If the point is contained by a display monitor, the return value is an <b>HMONITOR</b> handle to that display monitor. If the point is not contained by a display monitor, the return value depends on the value of <i>dwFlags</i>.</para>
    /// </returns>
    /// <remarks>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-monitorfrompoint">Learn more about this API from docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Graphics.Gdi.HMONITOR MonitorFromPoint(global::System.Drawing.Point pt, winmdroot.Graphics.Gdi.MONITOR_FROM_FLAGS dwFlags);

    /// <summary>Destroys the specified menu and frees any memory that the menu occupies.</summary>
    /// <param name="hMenu">
    /// <para>Type: <b>HMENU</b> A handle to the menu to be destroyed.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>Before closing, an application must use the <b>DestroyMenu</b> function to destroy a menu not assigned to a window. A menu that is assigned to a window is automatically destroyed when the application closes. <b>DestroyMenu</b> is recursive, that is, it will destroy the menu and all its submenus.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.BOOL DestroyMenu(winmdroot.UI.WindowsAndMessaging.HMENU hMenu);

    /// <inheritdoc cref="CreateWindowEx(winmdroot.UI.WindowsAndMessaging.WINDOW_EX_STYLE, winmdroot.Foundation.PCWSTR, winmdroot.Foundation.PCWSTR, winmdroot.UI.WindowsAndMessaging.WINDOW_STYLE, int, int, int, int, winmdroot.Foundation.HWND, winmdroot.UI.WindowsAndMessaging.HMENU, winmdroot.Foundation.HINSTANCE, void*)"/>
    [SupportedOSPlatform("windows5.0")]
    internal static unsafe winmdroot.Foundation.HWND CreateWindowEx(winmdroot.UI.WindowsAndMessaging.WINDOW_EX_STYLE dwExStyle, string lpClassName, string lpWindowName, winmdroot.UI.WindowsAndMessaging.WINDOW_STYLE dwStyle, int X, int Y, int nWidth, int nHeight, winmdroot.Foundation.HWND hWndParent, SafeHandle hMenu, SafeHandle hInstance, void* lpParam)
    {
      bool hMenuAddRef = false;
      bool hInstanceAddRef = false;
      try
      {
        fixed (char* lpWindowNameLocal = lpWindowName)
        {
          fixed (char* lpClassNameLocal = lpClassName)
          {
            winmdroot.UI.WindowsAndMessaging.HMENU hMenuLocal;
            if (hMenu is object)
            {
              hMenu.DangerousAddRef(ref hMenuAddRef);
              hMenuLocal = (winmdroot.UI.WindowsAndMessaging.HMENU)hMenu.DangerousGetHandle();
            }
            else
              hMenuLocal = (winmdroot.UI.WindowsAndMessaging.HMENU)new IntPtr(0L);
            winmdroot.Foundation.HINSTANCE hInstanceLocal;
            if (hInstance is object)
            {
              hInstance.DangerousAddRef(ref hInstanceAddRef);
              hInstanceLocal = (winmdroot.Foundation.HINSTANCE)hInstance.DangerousGetHandle();
            }
            else
              hInstanceLocal = (winmdroot.Foundation.HINSTANCE)new IntPtr(0L);
            winmdroot.Foundation.HWND __result = PInvoke.CreateWindowEx(dwExStyle, lpClassNameLocal, lpWindowNameLocal, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenuLocal, hInstanceLocal, lpParam);
            return __result;
          }
        }
      }
      finally
      {
        if (hMenuAddRef)
          hMenu.DangerousRelease();
        if (hInstanceAddRef)
          hInstance.DangerousRelease();
      }
    }

    /// <summary>Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function. (Unicode)</summary>
    /// <param name="dwExStyle">
    /// <para>Type: <b>DWORD</b> The extended window style of the window being created. For a list of possible values, see  <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Styles</a>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="lpClassName">
    /// <para>Type: <b>LPCTSTR</b> A <b>null</b>-terminated string or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. If <i>lpClassName</i> is a string, it specifies the window class name. The class name can be any name registered with <b>RegisterClass</b> or <b>RegisterClassEx</b>, provided that the module that registers the class is also the module that creates the window. The class name can also be any of the predefined <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">system class</a> names.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="lpWindowName">
    /// <para>Type: <b>LPCTSTR</b> The window name. If the window style specifies a title bar, the window title pointed to by <i>lpWindowName</i> is displayed in the title bar. When using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create controls, such as buttons, check boxes, and static controls, use <i>lpWindowName</i> to specify the text of the control. When creating a static control with the <b>SS_ICON</b> style, use <i>lpWindowName</i> to specify the icon name or identifier. To specify an identifier, use the syntax "#<i>num</i>".</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="dwStyle">
    /// <para>Type: <b>DWORD</b> The style of the window being created. This parameter can be a combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style values</a>, plus the control styles indicated in the Remarks section.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="X">
    /// <para>Type: <b>int</b> The initial horizontal position of the window. For an overlapped or pop-up window, the <i>x</i> parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>x</i> is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If <i>x</i> is set to <b>CW_USEDEFAULT</b>, the system selects the default position for the window's upper-left corner and ignores the <i>y</i> parameter. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if it is specified for a pop-up or child window, the <i>x</i> and <i>y</i> parameters are set to zero.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="Y">
    /// <para>Type: <b>int</b> The initial vertical position of the window. For an overlapped or pop-up window, the <i>y</i> parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>y</i> is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box <i>y</i> is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area.</para>
    /// <para>If an overlapped window is created with the <b>WS_VISIBLE</b> style bit set and the <i>x</i> parameter is set to <b>CW_USEDEFAULT</b>, then the <i>y</i> parameter determines how the window is shown. If the <i>y</i> parameter is <b>CW_USEDEFAULT</b>, then the window manager calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with the <b>SW_SHOW</b> flag after the window has been created. If the <i>y</i> parameter is some other value, then the window manager calls <b>ShowWindow</b> with that value as the <i>nCmdShow</i> parameter.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="nWidth">
    /// <para>Type: <b>int</b> The width, in device units, of the window. For overlapped windows, <i>nWidth</i> is the window's width, in screen coordinates, or <b>CW_USEDEFAULT</b>. If <i>nWidth</i> is <b>CW_USEDEFAULT</b>, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if <b>CW_USEDEFAULT</b> is specified for a pop-up or child window, the <i>nWidth</i> and <i>nHeight</i> parameter are set to zero.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="nHeight">
    /// <para>Type: <b>int</b> The height, in device units, of the window. For overlapped windows, <i>nHeight</i> is the window's height, in screen coordinates. If the <i>nWidth</i> parameter is set to <b>CW_USEDEFAULT</b>, the system ignores <i>nHeight</i>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="hWndParent">
    /// <para>Type: <b>HWND</b> A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window handle. This parameter is optional for pop-up windows. To create a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>, supply <b>HWND_MESSAGE</b> or a handle to an existing message-only window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="hMenu">
    /// <para>Type: <b>HMENU</b> A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, <i>hMenu</i> identifies the menu to be used with the window; it can be <b>NULL</b> if the class menu is to be used. For a child window, <i>hMenu</i> specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The application determines the child-window identifier; it must be unique for all child windows with the same parent window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="hInstance">
    /// <para>Type: <b>HINSTANCE</b> A handle to the instance of the module to be associated with the window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="lpParam">
    /// <para>Type: <b>LPVOID</b> Pointer to a value to be passed to the window through the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-createstructa">CREATESTRUCT</a> structure (<b>lpCreateParams</b> member) pointed to by the <i>lParam</i> param of the <b>WM_CREATE</b> message.  This message is sent to the created window by this function before it returns. If an application calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create a MDI client window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-clientcreatestruct">CLIENTCREATESTRUCT</a> structure. If an MDI client window calls <b>CreateWindow</b> to create an MDI child window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mdicreatestructa">MDICREATESTRUCT</a> structure. <i>lpParam</i> may be <b>NULL</b> if no additional data is needed.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>HWND</b> If the function succeeds, the return value is a handle to the new window. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function typically fails for one of the following reasons: </para>
    /// <para>This doc was truncated.</para>
    /// </returns>
    /// <remarks>
    /// <para>The <b>CreateWindowEx</b> function sends <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccreate">WM_NCCREATE</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccalcsize">WM_NCCALCSIZE</a>, and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-create">WM_CREATE</a> messages to the window being created. If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is itself topmost). For information on controlling whether the Taskbar displays a button for the created window, see <a href="https://docs.microsoft.com/windows/desktop/shell/taskbar">Managing Taskbar Buttons</a>. For information on removing a window, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function. The following predefined control classes can be specified in the <i>lpClassName</i> parameter. Note the corresponding control styles you can use in the <i>dwStyle</i> parameter. </para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "CreateWindowExW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern unsafe winmdroot.Foundation.HWND CreateWindowEx(winmdroot.UI.WindowsAndMessaging.WINDOW_EX_STYLE dwExStyle, winmdroot.Foundation.PCWSTR lpClassName, winmdroot.Foundation.PCWSTR lpWindowName, winmdroot.UI.WindowsAndMessaging.WINDOW_STYLE dwStyle, int X, int Y, int nWidth, int nHeight, winmdroot.Foundation.HWND hWndParent, winmdroot.UI.WindowsAndMessaging.HMENU hMenu, winmdroot.Foundation.HINSTANCE hInstance, [Optional] void* lpParam);

    /// <inheritdoc cref="GetClientRect(winmdroot.Foundation.HWND, winmdroot.Foundation.RECT*)"/>
    [SupportedOSPlatform("windows5.0")]
    internal static unsafe winmdroot.Foundation.BOOL GetClientRect(winmdroot.Foundation.HWND hWnd, out winmdroot.Foundation.RECT lpRect)
    {
      fixed (winmdroot.Foundation.RECT* lpRectLocal = &lpRect)
      {
        winmdroot.Foundation.BOOL __result = PInvoke.GetClientRect(hWnd, lpRectLocal);
        return __result;
      }
    }

    /// <summary>Retrieves the coordinates of a window's client area.</summary>
    /// <param name="hWnd">
    /// <para>Type: <b>HWND</b> A handle to the window whose client coordinates are to be retrieved.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclientrect#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="lpRect">
    /// <para>Type: <b>LPRECT</b> A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the client coordinates. The <b>left</b> and <b>top</b> members are zero. The <b>right</b> and <b>bottom</b> members contain the width and height of the window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclientrect#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>In conformance with conventions for the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure, the bottom-right coordinates of the returned rectangle are exclusive. In other words, the pixel at (<b>right</b>, <b>bottom</b>) lies immediately outside the rectangle.</remarks>
    [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern unsafe winmdroot.Foundation.BOOL GetClientRect(winmdroot.Foundation.HWND hWnd, winmdroot.Foundation.RECT* lpRect);

    /// <summary>Changes the parent window of the specified child window.</summary>
    /// <param name="hWndChild">
    /// <para>Type: <b>HWND</b> A handle to the child window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setparent#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="hWndNewParent">
    /// <para>Type: <b>HWND</b> A handle to the new parent window. If this parameter is <b>NULL</b>, the desktop window becomes the new parent window. If this parameter is <b>HWND_MESSAGE</b>, the child window becomes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setparent#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>HWND</b> If the function succeeds, the return value is a handle to the previous parent window. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>An application can use the <b>SetParent</b> function to set the parent window of a pop-up, overlapped, or child window. If the window identified by the <i>hWndChild</i> parameter is visible, the system performs the appropriate redrawing and repainting. For compatibility reasons, <b>SetParent</b> does not modify the <b>WS_CHILD</b> or <b>WS_POPUP</b> window styles of the window whose parent is being changed. Therefore, if <i>hWndNewParent</i> is <b>NULL</b>, you should also clear the <b>WS_CHILD</b> bit and set the <b>WS_POPUP</b> style after calling <b>SetParent</b>. Conversely, if <i>hWndNewParent</i> is not <b>NULL</b> and the window was previously a child of the desktop, you should clear the <b>WS_POPUP</b> style and set the <b>WS_CHILD</b> style before calling <b>SetParent</b>. When you change the parent of a window, you should synchronize the UISTATE of both windows. For more information, see <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-changeuistate">WM_CHANGEUISTATE</a> and <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-updateuistate">WM_UPDATEUISTATE</a>. Unexpected behavior or errors may occur if <i>hWndNewParent</i> and <i>hWndChild</i> are running in different DPI awareness modes. The table below outlines this behavior: </para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setparent#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.HWND SetParent(winmdroot.Foundation.HWND hWndChild, winmdroot.Foundation.HWND hWndNewParent);

    /// <summary>Changes the position and dimensions of the specified window.</summary>
    /// <param name="hWnd">
    /// <para>Type: <b>HWND</b> A handle to the window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="X">
    /// <para>Type: <b>int</b> The new position of the left side of the window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="Y">
    /// <para>Type: <b>int</b> The new position of the top of the window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="nWidth">
    /// <para>Type: <b>int</b> The new width of the window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="nHeight">
    /// <para>Type: <b>int</b> The new height of the window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="bRepaint">
    /// <para>Type: <b>BOOL</b> Indicates whether the window is to be repainted. If this parameter is <b>TRUE</b>, the window receives a  message. If the parameter is <b>FALSE</b>, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of moving a child window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-movewindow#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>If the <i>bRepaint</i> parameter is <b>TRUE</b>, the system sends the <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> message to the window procedure immediately after moving the window (that is, the <b>MoveWindow</b> function calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-updatewindow">UpdateWindow</a> function). If <i>bRepaint</i> is <b>FALSE</b>, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing. <b>MoveWindow</b> sends the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-windowposchanging">WM_WINDOWPOSCHANGING</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-windowposchanged">WM_WINDOWPOSCHANGED</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-move">WM_MOVE</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-size">WM_SIZE</a>, and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccalcsize">WM_NCCALCSIZE</a> messages to the window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-movewindow#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.BOOL MoveWindow(winmdroot.Foundation.HWND hWnd, int X, int Y, int nWidth, int nHeight, winmdroot.Foundation.BOOL bRepaint);

    /// <summary>Sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue.</summary>
    /// <param name="hWnd">
    /// <para>Type: **HWND** A handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setfocus#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: **HWND** If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the *hWnd* parameter is invalid or the window is not attached to the calling thread's message queue, the return value is NULL. To get extended error information, call [GetLastError function](../errhandlingapi/nf-errhandlingapi-getlasterror.md). Extended error ERROR_INVALID_PARAMETER (0x57) means that window is in disabled state.</para>
    /// </returns>
    /// <remarks>
    /// <para>This function sends a [WM_KILLFOCUS](/windows/desktop/inputdev/wm-killfocus) message to the window that loses the keyboard focus and a [WM_SETFOCUS](/windows/desktop/inputdev/wm-setfocus) message to the window that receives the keyboard focus. It also activates either the window that receives the focus or the parent of the window that receives the focus. If a window is active but does not have the focus, any key pressed produces the [WM_SYSCHAR](/windows/desktop/menurc/wm-syschar), [WM_SYSKEYDOWN](/windows/desktop/inputdev/wm-syskeydown), or [WM_SYSKEYUP](/windows/desktop/inputdev/wm-syskeyup) message. If the VK_MENU key is also pressed, bit 30 of the *lParam* parameter of the message is set. Otherwise, the messages produced do not have this bit set. By using the [AttachThreadInput function](nf-winuser-attachthreadinput.md), a thread can attach its input processing to another thread. This allows a thread to call SetFocus to set the keyboard focus to a window attached to another thread's message queue.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setfocus#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.HWND SetFocus(winmdroot.Foundation.HWND hWnd);

    /// <summary>Destroys the specified window.</summary>
    /// <param name="hWnd">
    /// <para>Type: <b>HWND</b> A handle to the window to be destroyed.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroywindow#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>A thread cannot use <b>DestroyWindow</b> to destroy a window created by a different thread. If the window being destroyed is a child window that does not have the <b>WS_EX_NOPARENTNOTIFY</b> style, a <a href="https://docs.microsoft.com/windows/win32/inputmsg/wm-parentnotify">WM_PARENTNOTIFY</a> message is sent to the parent.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroywindow#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.BOOL DestroyWindow(winmdroot.Foundation.HWND hWnd);

    /// <summary>Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a WM_DESTROY message.</summary>
    /// <param name="nExitCode">
    /// <para>Type: <b>int</b> The application exit code. This value is used as the <i>wParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postquitmessage#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <remarks>
    /// <para>The <b>PostQuitMessage</b> function posts a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message to the thread's message queue and returns immediately; the function simply indicates to the system that the thread is requesting to quit at some time in the future. When the thread retrieves the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message from its message queue, it should exit its message loop and return control to the system. The exit value returned to the system must be the <i>wParam</i> parameter of the <b>WM_QUIT</b> message.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postquitmessage#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern void PostQuitMessage(int nExitCode);

    /// <summary>Changes the size, position, and Z order of a child, pop-up, or top-level window. These windows are ordered according to their appearance on the screen. The topmost window receives the highest rank and is the first window in the Z order.</summary>
    /// <param name="hWnd">
    /// <para>Type: <b>HWND</b> A handle to the window.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="hWndInsertAfter">Type: <b>HWND</b></param>
    /// <param name="X">
    /// <para>Type: <b>int</b> The new position of the left side of the window, in client coordinates.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="Y">
    /// <para>Type: <b>int</b> The new position of the top of the window, in client coordinates.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="cx">
    /// <para>Type: <b>int</b> The new width of the window, in pixels.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="cy">
    /// <para>Type: <b>int</b> The new height of the window, in pixels.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowpos#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="uFlags">Type: <b>UINT</b></param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
    /// </returns>
    /// <remarks>
    /// <para>As part of the Vista re-architecture, all services were moved off the interactive desktop into Session 0. hwnd and window manager operations are only effective inside a session and cross-session attempts to manipulate the hwnd will fail. For more information, see <a href="https://docs.microsoft.com/previous-versions/aa480152(v=msdn.10)">The Windows Vista Developer Story: Application Compatibility Cookbook</a>. If you have changed certain window data using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a>, you must call <b>SetWindowPos</b> for the changes to take effect. Use the following combination for <i>uFlags</i>: <c>SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED</c>. A window can be made a topmost window either by setting the <i>hWndInsertAfter</i> parameter to <b>HWND_TOPMOST</b> and ensuring that the <b>SWP_NOZORDER</b> flag is not set, or by setting a window's position in the Z order so that it is above any existing topmost windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not changed. If neither the <b>SWP_NOACTIVATE</b> nor <b>SWP_NOZORDER</b> flag is specified (that is, when the application requests that a window be simultaneously activated and its position in the Z order changed), the value specified in <i>hWndInsertAfter</i> is used only in the following circumstances. </para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowpos#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.BOOL SetWindowPos(winmdroot.Foundation.HWND hWnd, winmdroot.Foundation.HWND hWndInsertAfter, int X, int Y, int cx, int cy, winmdroot.UI.WindowsAndMessaging.SET_WINDOW_POS_FLAGS uFlags);

    /// <summary>Calls the default window procedure to provide default processing for any window messages that an application does not process. (Unicode)</summary>
    /// <param name="hWnd">
    /// <para>Type: <b>HWND</b> A handle to the window procedure that received the message.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="Msg">
    /// <para>Type: <b>UINT</b> The message.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="wParam">
    /// <para>Type: <b>WPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="lParam">
    /// <para>Type: <b>LPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>LRESULT</b> The return value is the result of the message processing and depends on the message.</para>
    /// </returns>
    /// <remarks>
    /// <para>> [!NOTE] > The winuser.h header defines DefWindowProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "DefWindowProcW")]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.LRESULT DefWindowProc(winmdroot.Foundation.HWND hWnd, uint Msg, winmdroot.Foundation.WPARAM wParam, winmdroot.Foundation.LPARAM lParam);

    /// <summary>Changes an attribute of the specified window. (Unicode)</summary>
    /// <param name="hWnd">
    /// <para>Type: <b>HWND</b> A handle to the window and, indirectly, the class to which the window belongs. The <b>SetWindowLongPtr</b> function fails if the process that owns the window specified by the <i>hWnd</i> parameter is at a higher process privilege in the UIPI hierarchy than the process the calling thread resides in. <b>Windows XP/2000:  </b> The <b>SetWindowLongPtr</b> function fails if the window specified by the <i>hWnd</i> parameter does not belong to the same process as the calling thread.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongptrw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="nIndex">Type: <b>int</b></param>
    /// <param name="dwNewLong">
    /// <para>Type: <b>LONG_PTR</b> The replacement value.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongptrw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>LONG_PTR</b> If the function succeeds, the return value is the previous value of the specified offset. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the previous value is zero and the function succeeds, the return value is zero, but the function does not clear the last error information. To determine success or failure, clear the last error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0, then call <b>SetWindowLongPtr</b>. Function failure will be indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.</para>
    /// </returns>
    /// <remarks>
    /// <para>Certain window data is cached, so changes you make using <b>SetWindowLongPtr</b> will not take effect until you call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowpos">SetWindowPos</a> function. If you use <b>SetWindowLongPtr</b> with the <b>GWLP_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. If you use <b>SetWindowLongPtr</b> with the <b>DWLP_MSGRESULT</b> index to set the return value for a message processed by a dialog box procedure, the dialog box procedure should return <b>TRUE</b> directly afterward. Otherwise, if you call any function that results in your dialog box procedure receiving a window message, the nested window message could overwrite the return value you set by using <b>DWLP_MSGRESULT</b>. Calling <b>SetWindowLongPtr</b> with the <b>GWLP_WNDPROC</b> index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The <b>SetWindowLongPtr</b> function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a>. This allows the application to create a chain of window procedures. Reserve extra window memory by specifying a nonzero value in the <b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. Do not call <b>SetWindowLongPtr</b> with the <b>GWLP_HWNDPARENT</b> index to change the parent of a child window. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setparent">SetParent</a> function. If the window has a class style of <b>CS_CLASSDC</b> or <b>CS_PARENTDC</b>, do not set the extended window styles <b>WS_EX_COMPOSITED</b> or <b>WS_EX_LAYERED</b>. Calling <b>SetWindowLongPtr</b> to set the style on a progressbar will reset its position.</para>
    /// <para>> [!NOTE] > The winuser.h header defines SetWindowLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongptrw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern nint SetWindowLongPtr(winmdroot.Foundation.HWND hWnd, winmdroot.UI.WindowsAndMessaging.WINDOW_LONG_PTR_INDEX nIndex, nint dwNewLong);

    /// <summary>Retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory. (Unicode)</summary>
    /// <param name="hWnd">
    /// <para>Type: <b>HWND</b> A handle to the window and, indirectly, the class to which the window belongs.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowlongptrw#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="nIndex">Type: <b>int</b></param>
    /// <returns>
    /// <para>Type: <b>LONG_PTR</b> If the function succeeds, the return value is the requested value. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlongptra">SetWindowLongPtr</a> has not been called previously, <b>GetWindowLongPtr</b> returns zero for values in the extra window or class memory.</para>
    /// </returns>
    /// <remarks>
    /// <para>Reserve extra window memory by specifying a nonzero value in the <b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.</para>
    /// <para>> [!NOTE] > The winuser.h header defines GetWindowLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowlongptrw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern nint GetWindowLongPtr(winmdroot.Foundation.HWND hWnd, winmdroot.UI.WindowsAndMessaging.WINDOW_LONG_PTR_INDEX nIndex);

    /// <inheritdoc cref="GetMessage(winmdroot.UI.WindowsAndMessaging.MSG*, winmdroot.Foundation.HWND, uint, uint)"/>
    [SupportedOSPlatform("windows5.0")]
    internal static unsafe winmdroot.Foundation.BOOL GetMessage(out winmdroot.UI.WindowsAndMessaging.MSG lpMsg, winmdroot.Foundation.HWND hWnd, uint wMsgFilterMin, uint wMsgFilterMax)
    {
      fixed (winmdroot.UI.WindowsAndMessaging.MSG* lpMsgLocal = &lpMsg)
      {
        winmdroot.Foundation.BOOL __result = PInvoke.GetMessage(lpMsgLocal, hWnd, wMsgFilterMin, wMsgFilterMax);
        return __result;
      }
    }

    /// <summary>Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval. (GetMessageW)</summary>
    /// <param name="lpMsg">
    /// <para>Type: <b>LPMSG</b> A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information from the thread's message queue.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="hWnd">
    /// <para>Type: <b>HWND</b> A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
    /// <para>If <i>hWnd</i> is <b>NULL</b>, <b>GetMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed. If <i>hWnd</i> is -1, <b>GetMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>,  that is, thread messages as posted by  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="wMsgFilterMin">
    /// <para>Type: <b>UINT</b> The integer value of the lowest message value to be retrieved. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message. Use <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMax</i> to specify only the <b>WM_INPUT</b> messages. If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <param name="wMsgFilterMax">
    /// <para>Type: <b>UINT</b> The integer value of the highest message value to be retrieved. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message.</para>
    /// <para>Use <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMin</i> to specify only the <b>WM_INPUT</b> messages. If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the function retrieves a message other than <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a>, the return value is nonzero. If the function retrieves the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message, the return value is zero. If there is an error, the return value is -1. For example, the function fails if <i>hWnd</i> is an invalid window handle or <i>lpMsg</i> is an invalid pointer. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Because the return value can be nonzero, zero, or -1, avoid code like this:</para>
    /// <para></para>
    /// <para>This doc was truncated.</para>
    /// </returns>
    /// <remarks>
    /// <para>An application typically uses the return value to determine whether to end the main message loop and exit the program. The <b>GetMessage</b> function retrieves messages associated with the window identified by the <i>hWnd</i> parameter or any of its children, as specified by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-ischild">IsChild</a> function, and within the range of message values given by the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. Note that an application can only use the low word in the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters; the high word is reserved for the system. Note that <b>GetMessage</b> always retrieves <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> messages, no matter which values you specify for <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i>. During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a> function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:</para>
    /// <para></para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "GetMessageW", SetLastError = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern unsafe winmdroot.Foundation.BOOL GetMessage(winmdroot.UI.WindowsAndMessaging.MSG* lpMsg, winmdroot.Foundation.HWND hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

    /// <inheritdoc cref="TranslateMessage(winmdroot.UI.WindowsAndMessaging.MSG*)"/>
    [SupportedOSPlatform("windows5.0")]
    internal static unsafe winmdroot.Foundation.BOOL TranslateMessage(in winmdroot.UI.WindowsAndMessaging.MSG lpMsg)
    {
      fixed (winmdroot.UI.WindowsAndMessaging.MSG* lpMsgLocal = &lpMsg)
      {
        winmdroot.Foundation.BOOL __result = PInvoke.TranslateMessage(lpMsgLocal);
        return __result;
      }
    }

    /// <summary>Translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the next time the thread calls the GetMessage or PeekMessage function.</summary>
    /// <param name="lpMsg">
    /// <para>Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b> A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains message information retrieved from the calling thread's message queue by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translatemessage#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>BOOL</b> If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero. If the message is <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a>, <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a>, <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a>, or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a>, the return value is nonzero, regardless of the translation. If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.</para>
    /// </returns>
    /// <remarks>
    /// <para>The <b>TranslateMessage</b> function does not modify the message pointed to by the <i>lpMsg</i> parameter.</para>
    /// <para><a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a> combinations produce a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-char">WM_CHAR</a> or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-deadchar">WM_DEADCHAR</a> message. <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a> combinations produce a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syschar">WM_SYSCHAR</a> or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-sysdeadchar">WM_SYSDEADCHAR</a> message. <b>TranslateMessage</b> produces <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-char">WM_CHAR</a> messages only for keys that are mapped to ASCII characters by the keyboard driver. If applications process virtual-key messages for some other purpose, they should not call <b>TranslateMessage</b>. For instance, an application should not call <b>TranslateMessage</b> if the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-translateacceleratora">TranslateAccelerator</a> function returns a nonzero value. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a>. For more information, see  <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">Dialog Box Keyboard Interface</a>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translatemessage#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern unsafe winmdroot.Foundation.BOOL TranslateMessage(winmdroot.UI.WindowsAndMessaging.MSG* lpMsg);

    /// <inheritdoc cref="DispatchMessage(winmdroot.UI.WindowsAndMessaging.MSG*)"/>
    [SupportedOSPlatform("windows5.0")]
    internal static unsafe winmdroot.Foundation.LRESULT DispatchMessage(in winmdroot.UI.WindowsAndMessaging.MSG lpMsg)
    {
      fixed (winmdroot.UI.WindowsAndMessaging.MSG* lpMsgLocal = &lpMsg)
      {
        winmdroot.Foundation.LRESULT __result = PInvoke.DispatchMessage(lpMsgLocal);
        return __result;
      }
    }

    /// <summary>Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function. (DispatchMessageW)</summary>
    /// <param name="lpMsg">
    /// <para>Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b> A pointer to a structure that contains the message.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
    /// </param>
    /// <returns>
    /// <para>Type: <b>LRESULT</b> The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.</para>
    /// </returns>
    /// <remarks>
    /// <para>The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure must contain valid message values. If the <i>lpmsg</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message and the <i>lParam</i> parameter of the <b>WM_TIMER</b> message is not <b>NULL</b>, <i>lParam</i> points to a function that is called instead of the window procedure. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">Dialog Box Keyboard Interface</a>.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessagew#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "DispatchMessageW")]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern unsafe winmdroot.Foundation.LRESULT DispatchMessage(winmdroot.UI.WindowsAndMessaging.MSG* lpMsg);
  }


  /// <content>
  /// Contains extern methods from "GDI32.dll".
  /// </content>
  internal static partial class PInvoke
  {
    /// <summary>The DeleteObject function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid.</summary>
    /// <param name="ho">A handle to a logical pen, brush, font, bitmap, region, or palette.</param>
    /// <returns>
    /// <para>If the function succeeds, the return value is nonzero. If the specified handle is not valid or is currently selected into a DC, the return value is zero.</para>
    /// </returns>
    /// <remarks>
    /// <para>Do not delete a drawing object (pen or brush) while it is still selected into a DC. When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-deleteobject#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("GDI32.dll", ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows5.0")]
    internal static extern winmdroot.Foundation.BOOL DeleteObject(winmdroot.Graphics.Gdi.HGDIOBJ ho);
  }


  /// <content>
  /// Contains extern methods from "api-ms-win-shcore-scaling-l1-1-1.dll".
  /// </content>
  internal static partial class PInvoke
  {
    /// <inheritdoc cref="GetDpiForMonitor(winmdroot.Graphics.Gdi.HMONITOR, winmdroot.UI.HiDpi.MONITOR_DPI_TYPE, uint*, uint*)"/>
    [SupportedOSPlatform("windows8.1")]
    internal static unsafe winmdroot.Foundation.HRESULT GetDpiForMonitor(winmdroot.Graphics.Gdi.HMONITOR hmonitor, winmdroot.UI.HiDpi.MONITOR_DPI_TYPE dpiType, out uint dpiX, out uint dpiY)
    {
      fixed (uint* dpiYLocal = &dpiY)
      {
        fixed (uint* dpiXLocal = &dpiX)
        {
          winmdroot.Foundation.HRESULT __result = PInvoke.GetDpiForMonitor(hmonitor, dpiType, dpiXLocal, dpiYLocal);
          return __result;
        }
      }
    }

    /// <summary>Queries the dots per inch (dpi) of a display.</summary>
    /// <param name="hmonitor">Handle of the monitor being queried.</param>
    /// <param name="dpiType">The type of DPI being queried. Possible values are from the <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-monitor_dpi_type">MONITOR_DPI_TYPE</a> enumeration.</param>
    /// <param name="dpiX">The value of the DPI along the X axis. This value always refers to the horizontal edge, even when the screen is rotated.</param>
    /// <param name="dpiY">The value of the DPI along the Y axis. This value always refers to the vertical edge, even when the screen is rotated.</param>
    /// <returns>
    /// <para>This function returns one of the following values. </para>
    /// <para>This doc was truncated.</para>
    /// </returns>
    /// <remarks>
    /// <para>This API is not DPI aware and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdpiforwindow">GetDpiForWindow</a>. When you call <b>GetDpiForMonitor</b>, you will receive different DPI values depending on the DPI awareness of the calling application. DPI awareness is an application-level property usually defined in the application manifest. For more information about DPI awareness values, see <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-process_dpi_awareness">PROCESS_DPI_AWARENESS</a>. The following table indicates how the results will differ based on the <b>PROCESS_DPI_AWARENESS</b> value of your application. </para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/shellscalingapi/nf-shellscalingapi-getdpiformonitor#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DllImport("api-ms-win-shcore-scaling-l1-1-1.dll", ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows8.1")]
    internal static extern unsafe winmdroot.Foundation.HRESULT GetDpiForMonitor(winmdroot.Graphics.Gdi.HMONITOR hmonitor, winmdroot.UI.HiDpi.MONITOR_DPI_TYPE dpiType, uint* dpiX, uint* dpiY);
  }


  /// <summary>
  /// Represents a Win32 handle that can be closed with <see cref="PInvoke.DestroyCursor(winmdroot.UI.WindowsAndMessaging.HCURSOR)"/>.
  /// </summary>
  [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
  internal class DestroyCursorSafeHandle
    : SafeHandle
  {
    private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1L);

    internal DestroyCursorSafeHandle() : base(INVALID_HANDLE_VALUE, true)
    {
    }

    internal DestroyCursorSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true) : base(INVALID_HANDLE_VALUE, ownsHandle)
    {
      this.SetHandle(preexistingHandle);
    }

    public override bool IsInvalid => this.handle.ToInt64() == -1L || this.handle.ToInt64() == 0L;

    protected override bool ReleaseHandle() => PInvoke.DestroyCursor((winmdroot.UI.WindowsAndMessaging.HCURSOR)this.handle);
  }


  /// <summary>
  /// Represents a Win32 handle that can be closed with <see cref="PInvoke.FreeLibrary(winmdroot.Foundation.HMODULE)"/>.
  /// </summary>
  [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
  internal class FreeLibrarySafeHandle
    : SafeHandle
  {
    private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(0L);

    internal FreeLibrarySafeHandle() : base(INVALID_HANDLE_VALUE, true)
    {
    }

    internal FreeLibrarySafeHandle(IntPtr preexistingHandle, bool ownsHandle = true) : base(INVALID_HANDLE_VALUE, ownsHandle)
    {
      this.SetHandle(preexistingHandle);
    }

    public override bool IsInvalid => this.handle.ToInt64() == 0L;

    protected override bool ReleaseHandle() => PInvoke.FreeLibrary((winmdroot.Foundation.HMODULE)this.handle);
  }


  /// <summary>
  /// Represents a Win32 handle that can be closed with <see cref="PInvoke.DestroyIcon(winmdroot.UI.WindowsAndMessaging.HICON)"/>.
  /// </summary>
  [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
  internal class DestroyIconSafeHandle
    : SafeHandle
  {
    private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1L);

    internal DestroyIconSafeHandle() : base(INVALID_HANDLE_VALUE, true)
    {
    }

    internal DestroyIconSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true) : base(INVALID_HANDLE_VALUE, ownsHandle)
    {
      this.SetHandle(preexistingHandle);
    }

    public override bool IsInvalid => this.handle.ToInt64() == -1L || this.handle.ToInt64() == 0L;

    protected override bool ReleaseHandle() => PInvoke.DestroyIcon((winmdroot.UI.WindowsAndMessaging.HICON)this.handle);
  }

  internal static partial class PInvoke
  {
    /// <summary>Standard arrow cursor.</summary>
    /// <remarks>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo">Learn more about this API from docs.microsoft.com</see>.</para>
    /// </remarks>
    internal static readonly unsafe winmdroot.Foundation.PCWSTR IDC_ARROW = (char*)(32512);

    /// <summary>Sent prior to the WM\_CREATE message when a window is first created.</summary>
    /// <returns>
    /// <para>Type: **LRESULT** If an application processes this message, it should return **TRUE** to continue creation of the window. If the application returns **FALSE**, the [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) or [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function will return a **NULL** handle.</para>
    /// </returns>
    /// <remarks>
    /// <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-nccreate">Learn more about this API from docs.microsoft.com</see>.</para>
    /// </remarks>
    internal const uint WM_NCCREATE = 129U;

    /// <summary>Sent when a window is being destroyed. It is sent to the window procedure of the window being destroyed after the window is removed from the screen.</summary>
    /// <returns>
    /// <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
    /// </returns>
    /// <remarks>If the window being destroyed is part of the clipboard viewer chain (set by calling the [**SetClipboardViewer**](/windows/win32/api/winuser/nf-winuser-setclipboardviewer) function), the window must remove itself from the chain by processing the [**ChangeClipboardChain**](/windows/win32/api/winuser/nf-winuser-changeclipboardchain) function before returning from the **WM\_DESTROY** message.</remarks>
    internal const uint WM_DESTROY = 2U;

    /// <summary>Sent when the effective dots per inch (dpi) for a window has changed.</summary>
    /// <returns>If an application processes this message, it should return zero.</returns>
    /// <remarks>
    /// <para>This message is only relevant for **PROCESS\_PER\_MONITOR\_DPI\_AWARE** applications or **DPI\_AWARENESS\_PER\_MONITOR\_AWARE** threads. It may be received on certain DPI changes if your top-level window or process is running as **DPI unaware** or **system DPI aware**, but in those situations it can be safely ignored. For more information about the different types of awareness, see [**PROCESS\_DPI\_AWARENESS**](/windows/desktop/api/ShellScalingApi/ne-shellscalingapi-process_dpi_awareness) and [**DPI\_AWARENESS**](/windows/desktop/api/windef/ne-windef-dpi_awareness). Older versions of Windows required DPI awareness to be tied at the level of an application. Those apps use **PROCESS\_DPI\_AWARENESS**. Currently, DPI awareness is tied to threads and individual windows rather than the entire application. These apps use **DPI\_AWARENESS**. You only need to use either the X-axis or the Y-axis value when scaling your application since they are the same. In order to handle this message correctly, you will need to resize and reposition your window based on the suggestions provided by *lParam* and using [**SetWindowPos**](/windows/desktop/api/winuser/nf-winuser-setwindowpos). If you do not do this, your window will grow or shrink with respect to everything else on the new monitor. For example, if a user is using multiple monitors and drags your window from a 96 DPI monitor to a 192 DPI monitor, your window will appear to be half as large with respect to other items on the 192 DPI monitor. The base value of DPI is defined as **USER\_DEFAULT\_SCREEN\_DPI** which is set to 96. To determine the scaling factor for a monitor, take the DPI value and divide by **USER\_DEFAULT\_SCREEN\_DPI**. The following table provides some sample DPI values and associated scaling factors.</para>
    /// <para>| DPI value | Scaling percentage | |-----------|--------------------| | 96        | 100%               | | 120       | 125%               | | 144       | 150%               | | 192       | 200%               |</para>
    /// <para>The following example provides a sample DPI change handler.</para>
    /// <para></para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    internal const uint WM_DPICHANGED = 736U;

    /// <summary>Sent to a window after its size has changed.</summary>
    /// <returns>
    /// <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
    /// </returns>
    /// <remarks>
    /// <para>If the [**SetScrollPos**](https://msdn.microsoft.com/library/Cc411085(v=MSDN.10).aspx) or [**MoveWindow**](/windows/win32/api/winuser/nf-winuser-movewindow) function is called for a child window as a result of the **WM\_SIZE** message, the *bRedraw* or *bRepaint* parameter should be nonzero to cause the window to be repainted. Although the width and height of a window are 32-bit values, the *lParam* parameter contains only the low-order 16 bits of each. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the **WM\_SIZE** and **WM\_MOVE** messages when it processes the [**WM\_WINDOWPOSCHANGED**](wm-windowposchanged.md) message. The **WM\_SIZE** and **WM\_MOVE** messages are not sent if an application handles the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-size#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    internal const uint WM_SIZE = 5U;

    /// <summary>Sent to both the window being activated and the window being deactivated.</summary>
    /// <returns>If an application processes this message, it should return zero.</returns>
    /// <remarks>If the window is being activated and is not minimized, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets the keyboard focus to the window. If the window is activated by a mouse click, it also receives a [**WM\_MOUSEACTIVATE**](wm-mouseactivate.md) message.</remarks>
    internal const uint WM_ACTIVATE = 6U;

    /// <summary>An application sends the WM\_FONTCHANGE message to all top-level windows in the system after changing the pool of font resources.</summary>
    /// <remarks>
    /// <para>An application that adds or removes fonts from the system (for example, by using the [**AddFontResource**](/windows/desktop/api/Wingdi/nf-wingdi-addfontresourcea) or [**RemoveFontResource**](/windows/desktop/api/Wingdi/nf-wingdi-removefontresourcea) function) should send this message to all top-level windows. To send the **WM\_FONTCHANGE** message to all top-level windows, an application can call the **SendMessage** function with the *hwnd* parameter set to HWND\_BROADCAST.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-fontchange#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    internal const uint WM_FONTCHANGE = 29U;
  }

  namespace UI.WindowsAndMessaging
  {
    [Flags]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal enum WNDCLASS_STYLES : uint
    {
      CS_VREDRAW = 0x00000001,
      CS_HREDRAW = 0x00000002,
      CS_DBLCLKS = 0x00000008,
      CS_OWNDC = 0x00000020,
      CS_CLASSDC = 0x00000040,
      CS_PARENTDC = 0x00000080,
      CS_NOCLOSE = 0x00000200,
      CS_SAVEBITS = 0x00000800,
      CS_BYTEALIGNCLIENT = 0x00001000,
      CS_BYTEALIGNWINDOW = 0x00002000,
      CS_GLOBALCLASS = 0x00004000,
      CS_IME = 0x00010000,
      CS_DROPSHADOW = 0x00020000,
    }
    [UnmanagedFunctionPointerAttribute(CallingConvention.Winapi)]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal unsafe delegate winmdroot.Foundation.LRESULT WNDPROC(winmdroot.Foundation.HWND param0, uint param1, winmdroot.Foundation.WPARAM param2, winmdroot.Foundation.LPARAM param3);

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HICON
      : IEquatable<HICON>
    {
      internal readonly IntPtr Value;

      internal HICON(IntPtr value) => this.Value = value;

      internal static HICON Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(HICON value) => value.Value;

      public static explicit operator HICON(IntPtr value) => new HICON(value);

      public static bool operator ==(HICON left, HICON right) => left.Value == right.Value;

      public static bool operator !=(HICON left, HICON right) => !(left == right);

      public bool Equals(HICON other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HICON other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HCURSOR
      : IEquatable<HCURSOR>
    {
      internal readonly IntPtr Value;

      internal HCURSOR(IntPtr value) => this.Value = value;

      internal static HCURSOR Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(HCURSOR value) => value.Value;

      public static explicit operator HCURSOR(IntPtr value) => new HCURSOR(value);

      public static bool operator ==(HCURSOR left, HCURSOR right) => left.Value == right.Value;

      public static bool operator !=(HCURSOR left, HCURSOR right) => !(left == right);

      public bool Equals(HCURSOR other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HCURSOR other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";

      public static implicit operator HICON(HCURSOR value) => new HICON(value.Value);
    }

    /// <summary>Contains the window class attributes that are registered by the RegisterClass function. (Unicode)</summary>
    /// <remarks>
    /// <para>> [!NOTE] > The winuser.h header defines WNDCLASS as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal partial struct WNDCLASSW
    {
      /// <summary>
      /// <para>Type: <b>UINT</b> The class style(s). This member can be any combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">Class Styles</a>.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.UI.WindowsAndMessaging.WNDCLASS_STYLES style;

      /// <summary>
      /// <para>Type: <b>WNDPROC</b> A pointer to the window procedure. You must use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a> function to call the window procedure. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a>.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.UI.WindowsAndMessaging.WNDPROC lpfnWndProc;

      /// <summary>
      /// <para>Type: <b>int</b> The number of extra bytes to allocate following the window-class structure. The system initializes the bytes to zero.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal int cbClsExtra;

      /// <summary>
      /// <para>Type: <b>int</b> The number of extra bytes to allocate following the window instance. The system initializes the bytes to zero. If an application uses <b>WNDCLASS</b> to register a dialog box created by using the <b>CLASS</b> directive in the resource file, it must set this member to <b>DLGWINDOWEXTRA</b>.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal int cbWndExtra;

      /// <summary>
      /// <para>Type: <b>HINSTANCE</b> A handle to the instance that contains the window procedure for the class.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.HINSTANCE hInstance;

      /// <summary>
      /// <para>Type: <b>HICON</b> A handle to the class icon. This member must be a handle to an icon resource. If this member is <b>NULL</b>, the system provides a default icon.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.UI.WindowsAndMessaging.HICON hIcon;

      /// <summary>
      /// <para>Type: <b>HCURSOR</b> A handle to the class cursor. This member must be a handle to a cursor resource. If this member is <b>NULL</b>, an application must explicitly set the cursor shape whenever the mouse moves into the application's window.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.UI.WindowsAndMessaging.HCURSOR hCursor;

      /// <summary>
      /// <para>Type: <b>HBRUSH</b> A handle to the class background brush. This member can be a handle to the physical brush to be used for painting the background, or it can be a color value. A color value must be one of the following standard system colors (the value 1 must be added to the chosen color). If a color value is given, you must convert it to one of the following <b>HBRUSH</b> types:</para>
      /// <para></para>
      /// <para>This doc was truncated.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Graphics.Gdi.HBRUSH hbrBackground;

      /// <summary>
      /// <para>Type: <b>LPCTSTR</b> The resource name of the class menu, as the name appears in the resource file. If you use an integer to identify the menu, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro. If this member is <b>NULL</b>, windows belonging to this class have no default menu.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.PCWSTR lpszMenuName;

      /// <summary>
      /// <para>Type: <b>LPCTSTR</b> A pointer to a null-terminated string or is an atom. If this parameter is an atom, it must be a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <b>lpszClassName</b>; the high-order word must be zero.</para>
      /// <para>If <b>lpszClassName</b> is a string, it specifies the window class name. The class name can be any name registered with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names. The maximum length for <b>lpszClassName</b> is 256. If <b>lpszClassName</b> is greater than the maximum length, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> function will fail.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.PCWSTR lpszClassName;
    }

    [Flags]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal enum WINDOW_EX_STYLE : uint
    {
      WS_EX_DLGMODALFRAME = 0x00000001,
      WS_EX_NOPARENTNOTIFY = 0x00000004,
      WS_EX_TOPMOST = 0x00000008,
      WS_EX_ACCEPTFILES = 0x00000010,
      WS_EX_TRANSPARENT = 0x00000020,
      WS_EX_MDICHILD = 0x00000040,
      WS_EX_TOOLWINDOW = 0x00000080,
      WS_EX_WINDOWEDGE = 0x00000100,
      WS_EX_CLIENTEDGE = 0x00000200,
      WS_EX_CONTEXTHELP = 0x00000400,
      WS_EX_RIGHT = 0x00001000,
      WS_EX_LEFT = 0x00000000,
      WS_EX_RTLREADING = 0x00002000,
      WS_EX_LTRREADING = 0x00000000,
      WS_EX_LEFTSCROLLBAR = 0x00004000,
      WS_EX_RIGHTSCROLLBAR = 0x00000000,
      WS_EX_CONTROLPARENT = 0x00010000,
      WS_EX_STATICEDGE = 0x00020000,
      WS_EX_APPWINDOW = 0x00040000,
      WS_EX_OVERLAPPEDWINDOW = 0x00000300,
      WS_EX_PALETTEWINDOW = 0x00000188,
      WS_EX_LAYERED = 0x00080000,
      WS_EX_NOINHERITLAYOUT = 0x00100000,
      WS_EX_NOREDIRECTIONBITMAP = 0x00200000,
      WS_EX_LAYOUTRTL = 0x00400000,
      WS_EX_COMPOSITED = 0x02000000,
      WS_EX_NOACTIVATE = 0x08000000,
    }

    [Flags]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal enum WINDOW_STYLE : uint
    {
      WS_OVERLAPPED = 0x00000000,
      WS_POPUP = 0x80000000,
      WS_CHILD = 0x40000000,
      WS_MINIMIZE = 0x20000000,
      WS_VISIBLE = 0x10000000,
      WS_DISABLED = 0x08000000,
      WS_CLIPSIBLINGS = 0x04000000,
      WS_CLIPCHILDREN = 0x02000000,
      WS_MAXIMIZE = 0x01000000,
      WS_CAPTION = 0x00C00000,
      WS_BORDER = 0x00800000,
      WS_DLGFRAME = 0x00400000,
      WS_VSCROLL = 0x00200000,
      WS_HSCROLL = 0x00100000,
      WS_SYSMENU = 0x00080000,
      WS_THICKFRAME = 0x00040000,
      WS_GROUP = 0x00020000,
      WS_TABSTOP = 0x00010000,
      WS_MINIMIZEBOX = 0x00020000,
      WS_MAXIMIZEBOX = 0x00010000,
      WS_TILED = 0x00000000,
      WS_ICONIC = 0x20000000,
      WS_SIZEBOX = 0x00040000,
      WS_TILEDWINDOW = 0x00CF0000,
      WS_OVERLAPPEDWINDOW = 0x00CF0000,
      WS_POPUPWINDOW = 0x80880000,
      WS_CHILDWINDOW = 0x40000000,
      WS_ACTIVECAPTION = 0x00000001,
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HMENU
      : IEquatable<HMENU>
    {
      internal readonly IntPtr Value;

      internal HMENU(IntPtr value) => this.Value = value;

      internal static HMENU Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(HMENU value) => value.Value;

      public static explicit operator HMENU(IntPtr value) => new HMENU(value);

      public static bool operator ==(HMENU left, HMENU right) => left.Value == right.Value;

      public static bool operator !=(HMENU left, HMENU right) => !(left == right);

      public bool Equals(HMENU other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HMENU other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";
    }

    [Flags]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal enum SET_WINDOW_POS_FLAGS : uint
    {
      SWP_ASYNCWINDOWPOS = 0x00004000,
      SWP_DEFERERASE = 0x00002000,
      SWP_DRAWFRAME = 0x00000020,
      SWP_FRAMECHANGED = 0x00000020,
      SWP_HIDEWINDOW = 0x00000080,
      SWP_NOACTIVATE = 0x00000010,
      SWP_NOCOPYBITS = 0x00000100,
      SWP_NOMOVE = 0x00000002,
      SWP_NOOWNERZORDER = 0x00000200,
      SWP_NOREDRAW = 0x00000008,
      SWP_NOREPOSITION = 0x00000200,
      SWP_NOSENDCHANGING = 0x00000400,
      SWP_NOSIZE = 0x00000001,
      SWP_NOZORDER = 0x00000004,
      SWP_SHOWWINDOW = 0x00000040,
    }

    /// <summary>Defines the initialization parameters passed to the window procedure of an application. These members are identical to the parameters of the CreateWindowEx function. (Unicode)</summary>
    /// <remarks>
    /// <para>Because the <b>lpszClass</b> member can contain a pointer to a local (and thus inaccessible) atom, do not obtain the class name by using this member. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassname">GetClassName</a> function instead. You should access the data represented by the <b>lpCreateParams</b> member using a pointer that has been declared using the <b>UNALIGNED</b> type, because the pointer may not be <b>DWORD</b> aligned. This is demonstrated in the following example:</para>
    /// <para></para>
    /// <para>This doc was truncated.</para>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal partial struct CREATESTRUCTW
    {
      /// <summary>
      /// <para>Type: <b>LPVOID</b> Contains additional data which may be used to create the window. If the window is being created as a result of a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function, this member contains the value of the <i>lpParam</i> parameter specified in the function call. If the window being created is a MDI client window, this member contains a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-clientcreatestruct">CLIENTCREATESTRUCT</a> structure. If the window being created is a MDI child window, this member contains a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mdicreatestructa">MDICREATESTRUCT</a> structure. If the window is being created from a dialog template, this member is the address of a <b>SHORT</b> value that specifies the size, in bytes, of the window creation data. The value is immediately followed by the creation data. For more information, see the following Remarks section.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal unsafe void* lpCreateParams;

      /// <summary>
      /// <para>Type: <b>HINSTANCE</b> A handle to the module that owns the new window.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.HINSTANCE hInstance;

      /// <summary>
      /// <para>Type: <b>HMENU</b> A handle to the menu to be used by the new window.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.UI.WindowsAndMessaging.HMENU hMenu;

      /// <summary>
      /// <para>Type: <b>HWND</b> A handle to the parent window, if the window is a child window. If the window is owned, this member identifies the owner window. If the window is not a child or owned window, this member is <b>NULL</b>.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.HWND hwndParent;

      /// <summary>
      /// <para>Type: <b>int</b> The height of the new window, in pixels.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal int cy;

      /// <summary>
      /// <para>Type: <b>int</b> The width of the new window, in pixels.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal int cx;

      /// <summary>
      /// <para>Type: <b>int</b> The y-coordinate of the upper left corner of the new window. If the new window is a child window, coordinates are relative to the parent window. Otherwise, the coordinates are relative to the screen origin.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal int y;

      /// <summary>
      /// <para>Type: <b>int</b> The x-coordinate of the upper left corner of the new window. If the new window is a child window, coordinates are relative to the parent window. Otherwise, the coordinates are relative to the screen origin.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal int x;

      /// <summary>
      /// <para>Type: <b>LONG</b> The style for the new window. For a list of possible values, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">Window Styles</a>.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal int style;

      /// <summary>
      /// <para>Type: <b>LPCTSTR</b> The name of the new window.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.PCWSTR lpszName;

      /// <summary>
      /// <para>Type: <b>LPCTSTR</b> A pointer to a null-terminated string or an atom that specifies the class name of the new window.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.PCWSTR lpszClass;

      /// <summary>
      /// <para>Type: <b>DWORD</b> The extended window style for the new window. For a list of possible values, see  <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Styles</a>.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-createstructw#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal uint dwExStyle;
    }

    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal enum WINDOW_LONG_PTR_INDEX
    {
      GWL_EXSTYLE = -20,
      GWLP_HINSTANCE = -6,
      GWLP_HWNDPARENT = -8,
      GWLP_ID = -12,
      GWL_STYLE = -16,
      GWLP_USERDATA = -21,
      GWLP_WNDPROC = -4,
      GWL_HINSTANCE = -6,
      GWL_ID = -12,
      GWL_USERDATA = -21,
      GWL_WNDPROC = -4,
      GWL_HWNDPARENT = -8,
    }

    /// <summary>Contains message information from a thread's message queue.</summary>
    /// <remarks>
    /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg">Learn more about this API from docs.microsoft.com</see>.</para>
    /// </remarks>
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal partial struct MSG
    {
      /// <summary>
      /// <para>Type: <b>HWND</b> A handle to the window whose window procedure receives the message. This member is <b>NULL</b> when the message is a thread message.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.HWND hwnd;

      /// <summary>
      /// <para>Type: <b>UINT</b> The message identifier. Applications can only use the low word; the high word is reserved by the system.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal uint message;

      /// <summary>
      /// <para>Type: <b>WPARAM</b> Additional information about the message. The exact meaning depends on the value of the <b>message</b> member.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.WPARAM wParam;

      /// <summary>
      /// <para>Type: <b>LPARAM</b> Additional information about the message. The exact meaning depends on the value of the <b>message</b> member.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal winmdroot.Foundation.LPARAM lParam;

      /// <summary>
      /// <para>Type: <b>DWORD</b> The time at which the message was posted.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal uint time;

      /// <summary>
      /// <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b> The cursor position, in screen coordinates, when the message was posted.</para>
      /// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
      /// </summary>
      internal global::System.Drawing.Point pt;
    }
  }

  namespace Foundation
  {
    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct LRESULT
      : IEquatable<LRESULT>
    {
      internal readonly nint Value;

      internal LRESULT(nint value) => this.Value = value;

      public static implicit operator nint(LRESULT value) => value.Value;

      public static explicit operator LRESULT(nint value) => new LRESULT(value);

      public static bool operator ==(LRESULT left, LRESULT right) => left.Value == right.Value;

      public static bool operator !=(LRESULT left, LRESULT right) => !(left == right);

      public bool Equals(LRESULT other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is LRESULT other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct BOOL
      : IEquatable<BOOL>
    {
      internal readonly int Value;

      internal BOOL(int value) => this.Value = value;

      public static implicit operator int(BOOL value) => value.Value;

      public static explicit operator BOOL(int value) => new BOOL(value);

      public static bool operator ==(BOOL left, BOOL right) => left.Value == right.Value;

      public static bool operator !=(BOOL left, BOOL right) => !(left == right);

      public bool Equals(BOOL other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is BOOL other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";

      internal BOOL(bool value) => this.Value = value ? 1 : 0;

      public static implicit operator bool(BOOL value) => value.Value != 0;

      public static implicit operator BOOL(bool value) => new BOOL(value);
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HANDLE
      : IEquatable<HANDLE>
    {
      internal readonly IntPtr Value;

      internal HANDLE(IntPtr value) => this.Value = value;

      internal static HANDLE Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(HANDLE value) => value.Value;

      public static explicit operator HANDLE(IntPtr value) => new HANDLE(value);

      public static bool operator ==(HANDLE left, HANDLE right) => left.Value == right.Value;

      public static bool operator !=(HANDLE left, HANDLE right) => !(left == right);

      public bool Equals(HANDLE other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HANDLE other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HWND
      : IEquatable<HWND>
    {
      internal readonly IntPtr Value;

      internal HWND(IntPtr value) => this.Value = value;

      internal static HWND Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(HWND value) => value.Value;

      public static explicit operator HWND(IntPtr value) => new HWND(value);

      public static bool operator ==(HWND left, HWND right) => left.Value == right.Value;

      public static bool operator !=(HWND left, HWND right) => !(left == right);

      public bool Equals(HWND other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HWND other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";

      public static implicit operator HANDLE(HWND value) => new HANDLE(value.Value);
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct WPARAM
      : IEquatable<WPARAM>
    {
      internal readonly nuint Value;

      internal WPARAM(nuint value) => this.Value = value;

      public static implicit operator nuint(WPARAM value) => value.Value;

      public static implicit operator WPARAM(nuint value) => new WPARAM(value);

      public static bool operator ==(WPARAM left, WPARAM right) => left.Value == right.Value;

      public static bool operator !=(WPARAM left, WPARAM right) => !(left == right);

      public bool Equals(WPARAM other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is WPARAM other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct LPARAM
      : IEquatable<LPARAM>
    {
      internal readonly nint Value;

      internal LPARAM(nint value) => this.Value = value;

      public static implicit operator nint(LPARAM value) => value.Value;

      public static implicit operator LPARAM(nint value) => new LPARAM(value);

      public static bool operator ==(LPARAM left, LPARAM right) => left.Value == right.Value;

      public static bool operator !=(LPARAM left, LPARAM right) => !(left == right);

      public bool Equals(LPARAM other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is LPARAM other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HMODULE
      : IEquatable<HMODULE>
    {
      internal readonly IntPtr Value;

      internal HMODULE(IntPtr value) => this.Value = value;

      internal static HMODULE Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(HMODULE value) => value.Value;

      public static explicit operator HMODULE(IntPtr value) => new HMODULE(value);

      public static bool operator ==(HMODULE left, HMODULE right) => left.Value == right.Value;

      public static bool operator !=(HMODULE left, HMODULE right) => !(left == right);

      public bool Equals(HMODULE other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HMODULE other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";

      public static implicit operator HINSTANCE(HMODULE value) => new HINSTANCE(value.Value);
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HINSTANCE
      : IEquatable<HINSTANCE>
    {
      internal readonly IntPtr Value;

      internal HINSTANCE(IntPtr value) => this.Value = value;

      internal static HINSTANCE Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(HINSTANCE value) => value.Value;

      public static explicit operator HINSTANCE(IntPtr value) => new HINSTANCE(value);

      public static bool operator ==(HINSTANCE left, HINSTANCE right) => left.Value == right.Value;

      public static bool operator !=(HINSTANCE left, HINSTANCE right) => !(left == right);

      public bool Equals(HINSTANCE other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HINSTANCE other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";

      public static implicit operator HMODULE(HINSTANCE value) => new HMODULE(value.Value);
    }

    /// <remarks>
    /// <para>The **HRESULT** data type is the same as the [SCODE](scode.md) data type. An **HRESULT** value consists of the following fields: - A 1-bit code indicating severity, where zero represents success and 1 represents failure. - A 4-bit reserved value. - An 11-bit code indicating responsibility for the error or warning, also known as a facility code. - A 16-bit code describing the error or warning. Most MAPI interface methods and functions return **HRESULT** values to provide detailed cause formation. **HRESULT** values are also used widely in OLE interface methods. OLE provides several macros for converting between **HRESULT** values and **SCODE** values, another common data type for error handling. > [!NOTE] > In 64-bit MAPI, **HRESULT** is still a 32-bit value. For information about the OLE use of **HRESULT** values, see the  *OLE Programmer's Reference*. For more information about the use of these values in MAPI, see [Error Handling](error-handling-in-mapi.md) and any of the following interface methods: [IABLogon::GetLastError](iablogon-getlasterror.md) [IMAPISupport::GetLastError](imapisupport-getlasterror.md) [IMAPIControl::GetLastError](imapicontrol-getlasterror.md) [IMAPITable::GetLastError](imapitable-getlasterror.md) [IMAPIProp::GetLastError](imapiprop-getlasterror.md) [IMAPIViewAdviseSink::OnPrint](imapiviewadvisesink-onprint.md)</para>
    /// <para><see href="https://learn.microsoft.com/office/client-developer/outlook/mapi/hresult#">Read more on docs.microsoft.com</see>.</para>
    /// </remarks>
    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HRESULT
      : IEquatable<HRESULT>
    {
      internal readonly int Value;

      internal HRESULT(int value) => this.Value = value;

      public static implicit operator int(HRESULT value) => value.Value;

      public static explicit operator HRESULT(int value) => new HRESULT(value);

      public static bool operator ==(HRESULT left, HRESULT right) => left.Value == right.Value;

      public static bool operator !=(HRESULT left, HRESULT right) => !(left == right);

      public bool Equals(HRESULT other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HRESULT other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();


      public override string ToString() => string.Format(global::System.Globalization.CultureInfo.InvariantCulture, "0x{0:X8}", this.Value);

      public static implicit operator uint(HRESULT value) => (uint)value.Value;

      public static explicit operator HRESULT(uint value) => new HRESULT((int)value);


      [DebuggerBrowsable(DebuggerBrowsableState.Never)]
      internal bool Succeeded => this.Value >= 0;


      [DebuggerBrowsable(DebuggerBrowsableState.Never)]
      internal bool Failed => this.Value < 0;


      /// <inheritdoc cref="Marshal.ThrowExceptionForHR(int, IntPtr)" />
      /// <param name="errorInfo">
      /// A pointer to the IErrorInfo interface that provides more information about the
      /// error. You can specify <see cref="IntPtr.Zero"/> to use the current IErrorInfo interface, or
      /// <c>new IntPtr(-1)</c> to ignore the current IErrorInfo interface and construct the exception
      /// just from the error code.
      /// </param>
      /// <returns><see langword="this"/> <see cref="HRESULT"/>, if it does not reflect an error.</returns>
      /// <seealso cref="Marshal.ThrowExceptionForHR(int, IntPtr)"/>
      internal HRESULT ThrowOnFailure(IntPtr errorInfo = default)

      {
        Marshal.ThrowExceptionForHR(this.Value, errorInfo);
        return this;
      }


      internal string ToString(string format, IFormatProvider formatProvider) => ((uint)this.Value).ToString(format, formatProvider);
    }

    /// <summary>The RECT structure defines a rectangle by the coordinates of its upper-left and lower-right corners.</summary>
    /// <remarks>The RECT structure is identical to the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rectl">RECTL</a> structure.</remarks>
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal partial struct RECT
    {
      /// <summary>Specifies the <i>x</i>-coordinate of the upper-left corner of the rectangle.</summary>
      internal int left;

      /// <summary>Specifies the <i>y</i>-coordinate of the upper-left corner of the rectangle.</summary>
      internal int top;

      /// <summary>Specifies the <i>x</i>-coordinate of the lower-right corner of the rectangle.</summary>
      internal int right;

      /// <summary>Specifies the <i>y</i>-coordinate of the lower-right corner of the rectangle.</summary>
      internal int bottom;

      internal RECT(global::System.Drawing.Rectangle value) :
this(value.Left, value.Top, value.Right, value.Bottom)
      {
      }

      internal RECT(global::System.Drawing.Point location, global::System.Drawing.Size size) :
this(location.X, location.Y, unchecked(location.X + size.Width), unchecked(location.Y + size.Height))
      {
      }

      internal RECT(int left, int top, int right, int bottom)

      {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
      }


      internal static RECT FromXYWH(int x, int y, int width, int height) =>
new RECT(x, y, unchecked(x + width), unchecked(y + height));

      internal readonly int Width => unchecked(this.right - this.left);

      internal readonly int Height => unchecked(this.bottom - this.top);

      internal readonly bool IsEmpty => this.left == 0 && this.top == 0 && this.right == 0 && this.bottom == 0;

      internal readonly int X => this.left;

      internal readonly int Y => this.top;

      internal readonly global::System.Drawing.Size Size => new global::System.Drawing.Size(this.Width, this.Height);

      public static implicit operator global::System.Drawing.Rectangle(RECT value) => new global::System.Drawing.Rectangle(value.left, value.top, value.Width, value.Height);

      public static implicit operator global::System.Drawing.RectangleF(RECT value) => new global::System.Drawing.RectangleF(value.left, value.top, value.Width, value.Height);

      public static implicit operator RECT(global::System.Drawing.Rectangle value) => new RECT(value);
    }

    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal partial struct FARPROC
    {
      internal IntPtr Value;

      internal FARPROC(IntPtr value) => this.Value = value;

      internal static FARPROC Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(FARPROC value) => value.Value;

      public static explicit operator FARPROC(IntPtr value) => new FARPROC(value);

      public static bool operator ==(FARPROC left, FARPROC right) => left.Value == right.Value;

      public static bool operator !=(FARPROC left, FARPROC right) => !(left == right);

      public bool Equals(FARPROC other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is FARPROC other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";

      internal TDelegate CreateDelegate<TDelegate>() where TDelegate : Delegate => Marshal.GetDelegateForFunctionPointer<TDelegate>(this.Value);
    }

    /// <summary>
    /// A pointer to a null-terminated, constant character string.
    /// </summary>
    [DebuggerDisplay("{" + nameof(DebuggerDisplay) + "}")]
    internal unsafe readonly partial struct PCWSTR
      : IEquatable<PCWSTR>
    {
      /// <summary>
      /// A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
      /// </summary>
      internal readonly char* Value;

      internal PCWSTR(char* value) => this.Value = value;

      public static explicit operator char*(PCWSTR value) => value.Value;

      public static implicit operator PCWSTR(char* value) => new PCWSTR(value);

      public bool Equals(PCWSTR other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is PCWSTR other && this.Equals(other);

      public override int GetHashCode() => unchecked((int)this.Value);


      /// <summary>
      /// Gets the number of characters up to the first null character (exclusive).
      /// </summary>
      internal int Length
      {
        get
        {
          char* p = this.Value;
          if (p is null)
            return 0;
          while (*p != '\0')
            p++;
          return checked((int)(p - this.Value));
        }
      }


      /// <summary>
      /// Returns a <see langword="string"/> with a copy of this character array, up to the first null character (exclusive).
      /// </summary>
      /// <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="Value"/> is <see langword="null"/>.</returns>
      public override string ToString() => this.Value is null ? null : new string(this.Value);


      /// <summary>
      /// Returns a span of the characters in this string, up to the first null character (exclusive).
      /// </summary>
      internal ReadOnlySpan<char> AsSpan() => this.Value is null ? default(ReadOnlySpan<char>) : new ReadOnlySpan<char>(this.Value, this.Length);


      private string DebuggerDisplay => this.ToString();
    }

    /// <summary>
    /// A pointer to a null-terminated, constant, ANSI character string.
    /// </summary>
    [DebuggerDisplay("{" + nameof(DebuggerDisplay) + "}")]
    internal unsafe readonly partial struct PCSTR
      : IEquatable<PCSTR>
    {
      /// <summary>
      /// A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
      /// </summary>
      internal readonly byte* Value;

      internal PCSTR(byte* value) => this.Value = value;

      public static implicit operator byte*(PCSTR value) => value.Value;

      public static explicit operator PCSTR(byte* value) => new PCSTR(value);

      public bool Equals(PCSTR other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is PCSTR other && this.Equals(other);

      public override int GetHashCode() => unchecked((int)this.Value);


      /// <summary>
      /// Gets the number of characters up to the first null character (exclusive).
      /// </summary>
      internal int Length
      {
        get
        {
          byte* p = this.Value;
          if (p is null)
            return 0;
          while (*p != 0)
            p++;
          return checked((int)(p - this.Value));
        }
      }


      /// <summary>
      /// Returns a <see langword="string"/> with a copy of this character array, decoding as UTF-8.
      /// </summary>
      /// <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="Value"/> is <see langword="null"/>.</returns>
      public override string ToString() => this.Value is null ? null : new string((sbyte*)this.Value, 0, this.Length, global::System.Text.Encoding.Default);


      /// <summary>
      /// Returns a span of the characters in this string, up to the first null character (exclusive).
      /// </summary>
      internal ReadOnlySpan<byte> AsSpan() => this.Value is null ? default(ReadOnlySpan<byte>) : new ReadOnlySpan<byte>(this.Value, this.Length);


      private string DebuggerDisplay => this.ToString();
    }
  }

  namespace Graphics.Gdi
  {
    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HGDIOBJ
      : IEquatable<HGDIOBJ>
    {
      internal readonly IntPtr Value;

      internal HGDIOBJ(IntPtr value) => this.Value = value;

      internal static HGDIOBJ Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(HGDIOBJ value) => value.Value;

      public static explicit operator HGDIOBJ(IntPtr value) => new HGDIOBJ(value);

      public static bool operator ==(HGDIOBJ left, HGDIOBJ right) => left.Value == right.Value;

      public static bool operator !=(HGDIOBJ left, HGDIOBJ right) => !(left == right);

      public bool Equals(HGDIOBJ other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HGDIOBJ other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HBRUSH
      : IEquatable<HBRUSH>
    {
      internal readonly IntPtr Value;

      internal HBRUSH(IntPtr value) => this.Value = value;

      internal static HBRUSH Null => default;

      internal bool IsNull => Value == default;

      public static implicit operator IntPtr(HBRUSH value) => value.Value;

      public static explicit operator HBRUSH(IntPtr value) => new HBRUSH(value);

      public static bool operator ==(HBRUSH left, HBRUSH right) => left.Value == right.Value;

      public static bool operator !=(HBRUSH left, HBRUSH right) => !(left == right);

      public bool Equals(HBRUSH other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HBRUSH other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";

      public static implicit operator HGDIOBJ(HBRUSH value) => new HGDIOBJ(value.Value);
    }

    [DebuggerDisplay("{Value}")]
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal readonly partial struct HMONITOR
      : IEquatable<HMONITOR>
    {
      internal readonly nint Value;

      internal HMONITOR(nint value) => this.Value = value;

      public static implicit operator nint(HMONITOR value) => value.Value;

      public static explicit operator HMONITOR(nint value) => new HMONITOR(value);

      public static bool operator ==(HMONITOR left, HMONITOR right) => left.Value == right.Value;

      public static bool operator !=(HMONITOR left, HMONITOR right) => !(left == right);

      public bool Equals(HMONITOR other) => this.Value == other.Value;

      public override bool Equals(object obj) => obj is HMONITOR other && this.Equals(other);

      public override int GetHashCode() => this.Value.GetHashCode();

      public override string ToString() => $"0x{this.Value:x}";
    }

    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal enum MONITOR_FROM_FLAGS : uint
    {
      MONITOR_DEFAULTTONEAREST = 2U,
      MONITOR_DEFAULTTONULL = 0U,
      MONITOR_DEFAULTTOPRIMARY = 1U,
    }
  }

  namespace UI.HiDpi
  {
    /// <summary>Identifies the dots per inch (dpi) setting for a monitor.</summary>
    /// <remarks>All of these settings are affected by the <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-process_dpi_awareness">PROCESS_DPI_AWARENESS</a> of your application</remarks>
    [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
    internal enum MONITOR_DPI_TYPE
    {
      /// <summary>The effective DPI. This value should be used when determining the correct scale factor for scaling UI elements. This incorporates the scale factor set by the user for this specific display.</summary>
      MDT_EFFECTIVE_DPI = 0,
      /// <summary>The angular DPI. This DPI ensures rendering at a compliant angular resolution on the screen. This does not include the scale factor set by the user for this specific display.</summary>
      MDT_ANGULAR_DPI = 1,
      /// <summary>The raw DPI. This value is the linear DPI of the screen as measured on the screen itself. Use this value when you want to read the pixel density and not the recommended scaling setting. This does not include the scale factor set by the user for this specific display and is not guaranteed to be a supported DPI value.</summary>
      MDT_RAW_DPI = 2,
      /// <summary>The default DPI setting for a monitor is MDT_EFFECTIVE_DPI.</summary>
      MDT_DEFAULT = 0,
    }
  }
}
